<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Time Pixel Sorter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom scrollbar for minimalist look */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #fff; }
        ::-webkit-scrollbar-thumb { background: #000; border: 2px solid #fff; }
        
        /* Hide cursor in fullscreen if needed */
        .fullscreen-canvas { cursor: none; }
        
        /* Stats Tooltip Styling */
        .tooltip-trigger:hover .tooltip-content {
            display: block;
            animation: fadeIn 0.2s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Panning Cursors */
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        
        /* Canvas Transitions for smooth zoom toggle */
        #canvas {
            transition: transform 0.1s linear; /* Fast interaction */
        }
        
        /* Fit Mode */
        .canvas-fit {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        /* 1:1 Mode */
        .canvas-1to1 {
            max-width: none;
            max-height: none;
            position: absolute; /* Allows translation relative to wrapper */
            top: 0;
            left: 0;
            /* Transform is handled via JS inline styles */
        }
    </style>
</head>
<body class="bg-white text-black font-mono antialiased flex flex-col h-screen overflow-hidden selection:bg-black selection:text-white">

    <!-- Header -->
    <header class="flex justify-between items-center px-6 py-4 border-b-2 border-black z-30 bg-white">
        <h1 class="text-xl font-bold tracking-tighter uppercase">Real Time Pixel Sorter <span class="text-xs font-normal opacity-50 ml-2">v3.0 Color Science</span></h1>
        
        <!-- Status & Stats Tooltip Container -->
        <div class="relative tooltip-trigger cursor-help py-2">
            <div class="text-xs font-bold bg-black text-white px-2 py-1 uppercase tracking-wider transition-colors" id="status-text">WAITING FOR IMAGE</div>
            
            <!-- Tooltip Content -->
            <div class="tooltip-content hidden absolute top-full right-0 mt-2 w-64 bg-white border-2 border-black shadow-xl p-4 z-50 text-left pointer-events-none">
                <h3 class="text-xs font-bold uppercase border-b border-gray-200 pb-2 mb-2">Process Statistics</h3>
                <div class="space-y-1 text-xs text-gray-600">
                    <div class="flex justify-between"><span>Total Time:</span> <span id="stat-time" class="font-mono text-black">--</span></div>
                    <div class="flex justify-between"><span>Total Frames:</span> <span id="stat-frames" class="font-mono text-black">--</span></div>
                    <div class="flex justify-between"><span>Avg Render:</span> <span id="stat-render" class="font-mono text-black">--</span></div>
                    <div class="flex justify-between"><span>Est. FPS:</span> <span id="stat-fps" class="font-mono text-black">--</span></div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 relative flex items-center justify-center bg-gray-50 overflow-hidden p-4" id="main-container">
        
        <!-- Empty State / Drop Zone -->
        <div id="drop-zone" class="absolute inset-4 border-2 border-dashed border-gray-300 flex flex-col items-center justify-center text-gray-400 hover:border-black hover:text-black transition-colors cursor-pointer z-10">
            <i data-lucide="upload" class="w-12 h-12 mb-4"></i>
            <p class="uppercase text-sm tracking-widest">Drop Image or Click to Upload</p>
            <input type="file" id="file-input" class="hidden" accept="image/*">
        </div>

        <!-- Resize Dialog (Hidden by default) -->
        <div id="resize-dialog" class="absolute inset-0 bg-white/90 z-20 hidden flex flex-col items-center justify-center p-8 text-center backdrop-blur-sm transition-opacity">
            <div class="max-w-lg w-full border-2 border-black bg-white p-8 shadow-2xl">
                <h2 class="text-2xl font-bold mb-4 uppercase tracking-tighter">Large Image Detected</h2>
                <div class="grid grid-cols-2 gap-4 text-sm mb-6 border-y border-gray-200 py-4">
                    <div class="text-right pr-4 border-r border-gray-200">
                        <div class="text-gray-400 text-xs uppercase">Original</div>
                        <div id="dialog-img-dims" class="font-bold text-lg"></div>
                    </div>
                    <div class="text-left pl-4">
                        <div class="text-gray-400 text-xs uppercase">Your Screen</div>
                        <div id="dialog-screen-dims" class="font-bold text-lg"></div>
                    </div>
                </div>
                <p class="mb-8 text-gray-600 text-sm">
                    This image is larger than your workspace. Scaling it down will significantly improve sorting speed and frame rate.
                </p>
                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="btn-resize-fit" class="px-6 py-3 bg-black text-white font-bold uppercase hover:bg-gray-800 transition-colors flex-1">
                        Scale to Screen
                    </button>
                    <button id="btn-keep-orig" class="px-6 py-3 border-2 border-black font-bold uppercase hover:bg-gray-100 transition-colors flex-1">
                        Keep Original
                    </button>
                </div>
            </div>
        </div>

        <!-- Reset Confirmation Dialog -->
        <div id="confirm-reset-dialog" class="absolute inset-0 bg-white/90 z-30 hidden flex flex-col items-center justify-center p-8 text-center backdrop-blur-sm">
            <div class="max-w-md w-full border-2 border-black bg-white p-8 shadow-2xl">
                <div class="flex justify-center mb-4 text-red-600">
                    <i data-lucide="alert-triangle" class="w-12 h-12"></i>
                </div>
                <h2 class="text-xl font-bold mb-2 uppercase tracking-tighter">Interrupt Recording?</h2>
                <p class="mb-8 text-gray-600 text-sm">
                    A recording is currently in progress. Resetting now will discard the video file.
                </p>
                <div class="flex gap-4 justify-center">
                    <button id="btn-confirm-reset" class="px-6 py-2 bg-red-600 text-white font-bold uppercase hover:bg-red-700 transition-colors flex-1">
                        Yes, Reset
                    </button>
                    <button id="btn-cancel-reset" class="px-6 py-2 border-2 border-black font-bold uppercase hover:bg-gray-100 transition-colors flex-1">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Canvas Container -->
        <!-- Added overflow-hidden to act as the viewport for panning -->
        <div class="relative shadow-2xl border-4 border-black hidden flex flex-col justify-center items-center overflow-hidden bg-gray-100 cursor-grab" 
             style="width: 100%; height: 100%;" 
             id="canvas-wrapper">
            
            <!-- Canvas -->
            <!-- Classes toggled via JS for Fit vs 1:1 -->
            <canvas id="canvas" class="canvas-fit" title="Click to load a new image (or Drag to Pan in 1:1)"></canvas>
            
            <!-- Progress Overlay -->
            <div id="progress-bar-container" class="absolute bottom-0 left-0 h-1 bg-black w-0 transition-all duration-300 z-10"></div>
        </div>

    </main>

    <!-- Controls Footer -->
    <footer class="border-t-2 border-black bg-white p-4 z-30">
        <div class="flex flex-wrap gap-4 items-center justify-center md:justify-between max-w-7xl mx-auto">
            
            <!-- Left: Info & View Mode -->
            <div class="flex gap-4 items-center text-sm text-gray-500">
                <span id="resolution-display">0 x 0</span>
                <div class="h-4 w-px bg-gray-300"></div>
                <button id="btn-zoom-toggle" class="flex items-center gap-2 hover:text-black transition-colors" title="Toggle 1:1 View">
                    <i data-lucide="zoom-in" class="w-4 h-4"></i>
                    <span id="zoom-label" class="text-xs uppercase font-bold">Fit Screen</span>
                </button>
                <div class="h-4 w-px bg-gray-300"></div>
                
                <div class="flex gap-2">
                     <select id="color-mode" class="bg-transparent font-bold uppercase text-xs cursor-pointer outline-none hover:text-black transition-colors" title="Color Space / Sorting Algorithm">
                        <option value="smart">Smart (HSV+)</option>
                        <option value="cielab">CIELAB (L*)</option>
                        <option value="luma">Luminance</option>
                        <option value="classic">Classic (8-bit)</option>
                        <option value="sat">Saturation</option>
                        <option value="red">Red</option>
                        <option value="green">Green</option>
                        <option value="blue">Blue</option>
                    </select>
                </div>
                
                <div class="h-4 w-px bg-gray-300"></div>
                
                <div class="flex gap-2">
                    <select id="sort-mode" class="bg-transparent font-bold uppercase text-xs cursor-pointer outline-none hover:text-black transition-colors" title="Axis Mode">
                        <option value="xy">XY (Mix)</option>
                        <option value="y">Y Only</option>
                        <option value="x">X Only</option>
                    </select>
                    <!-- Dynamic Direction Select -->
                    <select id="gravity-direction" class="bg-transparent font-bold uppercase text-xs cursor-pointer outline-none hover:text-black transition-colors" title="Gravity Direction">
                        <!-- Populated via JS -->
                    </select>
                </div>
            </div>

            <!-- Center: Actions -->
            <div class="flex gap-3">
                <button id="btn-reset" class="px-6 py-2 border-2 border-black uppercase text-sm font-bold hover:bg-black hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled>
                    Reset
                </button>
                <button id="btn-use-input" class="px-6 py-2 border-2 border-black uppercase text-sm font-bold hover:bg-gray-100 transition-colors disabled:opacity-30 disabled:cursor-not-allowed" title="Use current result as input for new sorts" disabled>
                    Use as Input
                </button>
                <div class="w-px bg-gray-300 mx-2"></div>
                <button id="btn-sort" class="px-6 py-2 border-2 border-black uppercase text-sm font-bold hover:bg-black hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled>
                    Start Sort
                </button>
                <button id="btn-record" class="px-6 py-2 border-2 border-black bg-black text-white uppercase text-sm font-bold hover:bg-white hover:text-black transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled>
                    Record Sort
                </button>
            </div>

            <!-- Right: Tools -->
            <div class="flex gap-3">
                <button id="btn-fullscreen" class="p-2 border-2 border-black hover:bg-black hover:text-white transition-colors" title="Maximize Preview">
                    <i data-lucide="maximize" class="w-5 h-5"></i>
                </button>
                <button id="btn-download" class="p-2 border-2 border-black hover:bg-black hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled title="Download WebM">
                    <i data-lucide="download" class="w-5 h-5"></i>
                </button>
            </div>
        </div>
    </footer>

    <script>
        // --- Icons ---
        lucide.createIcons();

        // --- Core Elements ---
        const mainContainer = document.getElementById('main-container');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const canvas = document.getElementById('canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Dialog Elements
        const resizeDialog = document.getElementById('resize-dialog');
        const dialogImgDims = document.getElementById('dialog-img-dims');
        const dialogScreenDims = document.getElementById('dialog-screen-dims');
        const btnResizeFit = document.getElementById('btn-resize-fit');
        const btnKeepOrig = document.getElementById('btn-keep-orig');

        // Reset Confirmation Elements
        const confirmResetDialog = document.getElementById('confirm-reset-dialog');
        const btnConfirmReset = document.getElementById('btn-confirm-reset');
        const btnCancelReset = document.getElementById('btn-cancel-reset');

        // Buttons & Stats
        const btnSort = document.getElementById('btn-sort');
        const btnRecord = document.getElementById('btn-record');
        const btnReset = document.getElementById('btn-reset');
        const btnUseInput = document.getElementById('btn-use-input');
        const btnDownload = document.getElementById('btn-download');
        const btnFullscreen = document.getElementById('btn-fullscreen');
        const btnZoomToggle = document.getElementById('btn-zoom-toggle');
        const zoomLabel = document.getElementById('zoom-label');
        const sortModeInput = document.getElementById('sort-mode');
        const gravityInput = document.getElementById('gravity-direction');
        const colorModeInput = document.getElementById('color-mode');
        
        const statusText = document.getElementById('status-text');
        const resDisplay = document.getElementById('resolution-display');
        const progressBar = document.getElementById('progress-bar-container');
        
        // Stat fields
        const statTime = document.getElementById('stat-time');
        const statFrames = document.getElementById('stat-frames');
        const statRender = document.getElementById('stat-render');
        const statFps = document.getElementById('stat-fps');

        // --- State ---
        let originalImage = null;
        let animationId = null;
        let isSorting = false;
        let currentRunIsRecording = false; // Track active mode
        
        // View State
        let viewMode = 'fit'; // 'fit' or '1to1'
        let pan = { x: 0, y: 0 };
        let isPanning = false;
        let startPan = { x: 0, y: 0 };
        let wasPanning = false; // Flag to prevent click event after drag

        // Statistics State
        let stats = {
            startTime: 0,
            endTime: 0,
            totalFrames: 0,
            totalRenderTime: 0
        };
        
        // Data Buffers
        let pixelData = null; // Uint8ClampedArray (Visuals)
        let weightData = null; // Float32Array (Physics)
        let width = 0;
        let height = 0;

        // Recording State
        let mediaRecorder = null;
        let recordedChunks = [];
        let stream = null;
        let videoURL = null;

        // --- Gravity Options Logic ---
        function updateGravityOptions() {
            const mode = sortModeInput.value;
            gravityInput.innerHTML = ''; // Clear existing
            
            let options = [];
            
            if (mode === 'xy') {
                options = [
                    { val: 'dr', text: '↘ Down-Right' },
                    { val: 'dl', text: '↙ Down-Left' },
                    { val: 'ur', text: '↗ Up-Right' },
                    { val: 'ul', text: '↖ Up-Left' }
                ];
            } else if (mode === 'y') {
                options = [
                    { val: 'd', text: '↓ Down' },
                    { val: 'u', text: '↑ Up' }
                ];
            } else if (mode === 'x') {
                options = [
                    { val: 'r', text: '→ Right' },
                    { val: 'l', text: '← Left' }
                ];
            }
            
            options.forEach(opt => {
                const el = document.createElement('option');
                el.value = opt.val;
                el.textContent = opt.text;
                gravityInput.appendChild(el);
            });
        }
        
        // Initialize options on load
        updateGravityOptions();
        sortModeInput.addEventListener('change', updateGravityOptions);


        // --- Event Listeners ---
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('bg-gray-100'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('bg-gray-100'));
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
        
        // --- Pan & Zoom Logic ---
        
        btnZoomToggle.addEventListener('click', toggleZoomMode);

        canvasWrapper.addEventListener('mousedown', (e) => {
            if (viewMode === '1to1') {
                isPanning = true;
                wasPanning = false;
                startPan.x = e.clientX - pan.x;
                startPan.y = e.clientY - pan.y;
                canvasWrapper.classList.add('cursor-grabbing');
                canvasWrapper.classList.remove('cursor-grab');
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isPanning && viewMode === '1to1') {
                wasPanning = true; // User has moved, so it's a drag
                pan.x = e.clientX - startPan.x;
                pan.y = e.clientY - startPan.y;
                updateCanvasTransform();
            }
        });

        window.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                canvasWrapper.classList.remove('cursor-grabbing');
                if (viewMode === '1to1') canvasWrapper.classList.add('cursor-grab');
            }
        });

        // Click to Upload (Only if not panning/sorting)
        canvasWrapper.addEventListener('click', (e) => {
            // If we were dragging (wasPanning) in 1:1 mode, don't trigger upload
            if (viewMode === '1to1' && wasPanning) {
                wasPanning = false;
                return;
            }
            // If sorting, ignore click
            if (isSorting) return;
            
            // Trigger upload
            fileInput.click();
        });


        // --- Control Listeners ---

        btnSort.addEventListener('click', () => startSortingProcess(false));
        btnRecord.addEventListener('click', () => startSortingProcess(true));
        
        btnReset.addEventListener('click', () => {
            if (isSorting && currentRunIsRecording) {
                // Only show confirmation if we are actually recording
                confirmResetDialog.classList.remove('hidden');
            } else {
                // Instant reset for normal sorting or idle
                resetCanvasState();
            }
        });
        
        btnUseInput.addEventListener('click', setAsInput);

        btnConfirmReset.addEventListener('click', () => {
            confirmResetDialog.classList.add('hidden');
            resetCanvasState();
        });

        btnCancelReset.addEventListener('click', () => {
            confirmResetDialog.classList.add('hidden');
        });

        btnDownload.addEventListener('click', downloadVideo);
        btnFullscreen.addEventListener('click', toggleFullscreen);

        // Dialog Listeners
        btnResizeFit.addEventListener('click', () => {
            resizeDialog.classList.add('hidden');
            initCanvas(originalImage, true);
        });

        btnKeepOrig.addEventListener('click', () => {
            resizeDialog.classList.add('hidden');
            initCanvas(originalImage, false);
        });

        // --- File Handling ---
        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('bg-gray-100');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        }

        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    checkDimensionsAndInit(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function checkDimensionsAndInit(img) {
            // Get available space (subtract padding)
            const pad = 40;
            const availW = mainContainer.clientWidth - pad;
            const availH = mainContainer.clientHeight - pad;

            const imgW = img.width;
            const imgH = img.height;

            if (imgW > availW * 1.2 || imgH > availH * 1.2) {
                dialogImgDims.textContent = `${imgW} x ${imgH}`;
                dialogScreenDims.textContent = `${availW} x ${availH}`;
                resizeDialog.classList.remove('hidden');
                dropZone.classList.add('hidden');
            } else {
                dropZone.classList.add('hidden');
                initCanvas(img, false);
            }
        }
        
        // --- Endless Sorting Logic ---
        
        function setAsInput() {
            if (!width || !height) return;
            
            // 1. Snapshot Current Canvas State
            const dataURL = canvas.toDataURL();
            
            // 2. Stop any current sorting nicely
            if (isSorting) {
                isSorting = false;
                cancelAnimationFrame(animationId);
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.onstop = null;
                    mediaRecorder.stop();
                }
                btnSort.disabled = false;
                btnRecord.disabled = false;
            }
            
            // 3. Update Original Image
            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                
                // Immediately reset to prepare for new run
                resetCanvasState();

                // Visual Feedback
                statusText.textContent = "IMAGE UPDATED AS INPUT";
                statusText.classList.add('bg-blue-600', 'text-white');
                setTimeout(() => {
                    if (!isSorting && statusText.textContent === "IMAGE UPDATED AS INPUT") {
                        statusText.textContent = "READY";
                        statusText.classList.remove('bg-blue-600', 'text-white');
                    }
                }, 1500);
            };
            newImg.src = dataURL;
        }

        // --- Zoom Logic ---

        function toggleZoomMode() {
            if (!width || !height) return;

            if (viewMode === 'fit') {
                // Switch to 1:1
                viewMode = '1to1';
                zoomLabel.textContent = "1:1 View";
                canvas.classList.remove('canvas-fit');
                canvas.classList.add('canvas-1to1');
                canvasWrapper.classList.add('cursor-grab');
                canvasWrapper.classList.remove('justify-center', 'items-center'); // Allow free movement
                
                // Center initially
                const wrapperW = canvasWrapper.clientWidth;
                const wrapperH = canvasWrapper.clientHeight;
                pan.x = (wrapperW - width) / 2;
                pan.y = (wrapperH - height) / 2;
                updateCanvasTransform();
            } else {
                // Switch to Fit
                viewMode = 'fit';
                zoomLabel.textContent = "Fit Screen";
                canvas.classList.add('canvas-fit');
                canvas.classList.remove('canvas-1to1');
                canvasWrapper.classList.remove('cursor-grab', 'cursor-grabbing');
                canvasWrapper.classList.add('justify-center', 'items-center');
                canvas.style.transform = ''; // Clear transform
            }
        }

        function updateCanvasTransform() {
            if (viewMode === '1to1') {
                canvas.style.transform = `translate(${pan.x}px, ${pan.y}px)`;
            }
        }

        // --- Canvas Setup & Helpers ---
        
        function resetCanvasState() {
            if (animationId) cancelAnimationFrame(animationId);
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.onstop = null;
                mediaRecorder.stop();
            }
            isSorting = false;
            currentRunIsRecording = false;
            
            if (videoURL) URL.revokeObjectURL(videoURL);
            btnDownload.disabled = true;
            
            btnSort.disabled = false;
            btnRecord.disabled = false;
            btnUseInput.disabled = false;
            
            progressBar.style.width = '0%';
            progressBar.classList.remove('bg-green-500');
            statusText.textContent = "READY";
            
            // Reset Stats
            statTime.textContent = "--";
            statFrames.textContent = "--";
            statRender.textContent = "--";
            statFps.textContent = "--";
            
            // Restore Original Image (This might be the new input if updated!)
            if (width && height && originalImage) {
                ctx.drawImage(originalImage, 0, 0, width, height);
                const newData = ctx.getImageData(0, 0, width, height);
                pixelData = newData.data;
            }
            
            // Reset View
            if (viewMode === '1to1') toggleZoomMode(); // Go back to fit on reset
        }

        function initCanvas(img, resizeToFit) {
            resetCanvasState();
            
            let w = img.width;
            let h = img.height;
            const maxDim = 3840; // 4K cap

            if (resizeToFit) {
                const pad = 40;
                const availW = mainContainer.clientWidth - pad;
                const availH = mainContainer.clientHeight - pad;
                const ratio = Math.min(availW / w, availH / h);
                w = Math.round(w * ratio);
                h = Math.round(h * ratio);
            } else {
                if (w > maxDim || h > maxDim) {
                    const ratio = Math.min(maxDim / w, maxDim / h);
                    w = Math.round(w * ratio);
                    h = Math.round(h * ratio);
                }
            }

            canvas.width = w;
            canvas.height = h;
            width = w;
            height = h;
            
            ctx.drawImage(img, 0, 0, w, h);
            
            const imageData = ctx.getImageData(0, 0, w, h);
            pixelData = imageData.data;

            canvasWrapper.classList.remove('hidden');
            resDisplay.textContent = `${w} x ${h}`;
            statusText.textContent = "READY";
            
            btnSort.disabled = false;
            btnRecord.disabled = false;
            btnReset.disabled = false;
            btnDownload.disabled = true;
            btnUseInput.disabled = false;
            
            // Ensure we start in fit mode
            viewMode = 'fit';
            zoomLabel.textContent = "Fit Screen";
            canvas.classList.add('canvas-fit');
            canvas.classList.remove('canvas-1to1');
            canvasWrapper.classList.add('justify-center', 'items-center');
            canvasWrapper.classList.remove('cursor-grab');
            canvas.style.transform = '';
        }

        // --- Physics Engine (Calculates weights based on Mode) ---

        function calculateWeights(data, w, h) {
            const weights = new Float32Array(w * h);
            const mode = colorModeInput.value;
            
            for (let i = 0; i < w * h; i++) {
                const idx = i * 4;
                const r = data[idx];     // 0-255
                const g = data[idx + 1];
                const b = data[idx + 2];
                // Normalize 0-1 for standard calculations
                const rn = r / 255;
                const gn = g / 255;
                const bn = b / 255;
                
                let weight = 0;

                if (mode === 'smart') {
                    // Smart (HSV): Value + Hue Bias
                    const max = Math.max(rn, gn, bn);
                    const min = Math.min(rn, gn, bn);
                    const d = max - min;
                    let hue = 0;
                    if (max !== min) {
                        if (max === rn) hue = (gn - bn) / d + (gn < bn ? 6 : 0);
                        else if (max === gn) hue = (bn - rn) / d + 2;
                        else if (max === bn) hue = (rn - gn) / d + 4;
                        hue /= 6;
                    }
                    weight = max + (hue * 0.005);
                } 
                else if (mode === 'classic') {
                    // Classic: 8-bit quantized luminance (mimics retro behavior)
                    const luma = (0.299 * r + 0.587 * g + 0.114 * b);
                    // Quantize to steps of 24 (or similar retro feel) to force banding
                    weight = Math.floor(luma / 24) * 24; 
                }
                else if (mode === 'cielab') {
                    // CIELAB L*: Perceptual Lightness (Approximation)
                    // 1. RGB to Linear
                    const lin = (c) => (c <= 0.04045) ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                    const Rl = lin(rn), Gl = lin(gn), Bl = lin(bn);
                    // 2. Linear RGB to Y (Luminance part of XYZ)
                    const Y = 0.2126 * Rl + 0.7152 * Gl + 0.0722 * Bl;
                    // 3. Y to L*
                    const Yn = 1.0; // Reference white
                    const f = (t) => (t > 0.008856) ? Math.pow(t, 1/3) : (7.787 * t) + (16 / 116);
                    weight = (116 * f(Y / Yn)) - 16;
                }
                else if (mode === 'luma') {
                    // Rec. 709 Luminance (High Precision)
                    weight = 0.2126 * rn + 0.7152 * gn + 0.0722 * bn;
                }
                else if (mode === 'sat') {
                    // Saturation
                    const max = Math.max(rn, gn, bn);
                    const min = Math.min(rn, gn, bn);
                    weight = (max === 0) ? 0 : (max - min) / max;
                }
                else if (mode === 'red') {
                    // Red Isolation (with tiny bias to prevent collisions)
                    weight = rn + (gn * 0.001) + (bn * 0.001);
                }
                else if (mode === 'green') {
                    weight = gn + (rn * 0.001) + (bn * 0.001);
                }
                else if (mode === 'blue') {
                    weight = bn + (rn * 0.001) + (gn * 0.001);
                }
                
                weights[i] = weight;
            }
            return weights;
        }

        function swap(i1, i2) {
            const tempW = weightData[i1];
            weightData[i1] = weightData[i2];
            weightData[i2] = tempW;

            const p1 = i1 * 4;
            const p2 = i2 * 4;
            
            const r = pixelData[p1];
            const g = pixelData[p1+1];
            const b = pixelData[p1+2];
            const a = pixelData[p1+3];

            pixelData[p1] = pixelData[p2];
            pixelData[p1+1] = pixelData[p2+1];
            pixelData[p1+2] = pixelData[p2+2];
            pixelData[p1+3] = pixelData[p2+3];

            pixelData[p2] = r;
            pixelData[p2+1] = g;
            pixelData[p2+2] = b;
            pixelData[p2+3] = a;
        }

        // --- Sorting Animation Loop ---

        async function startSortingProcess(isRecordingMode) {
            if (isSorting) return;
            isSorting = true;
            currentRunIsRecording = isRecordingMode;
            btnSort.disabled = true;
            btnRecord.disabled = true;
            btnReset.disabled = false; // Reset enabled for interrupt
            btnUseInput.disabled = false; // Allow "Use as Input" during sort to capture intermediate state
            btnDownload.disabled = true;
            
            // Get Mode & Gravity
            const mode = sortModeInput.value;
            const gravity = gravityInput.value;
            
            // Determine inversion based on direction selected
            let invertX = false;
            let invertY = false;
            
            if (gravity.includes('u')) invertY = true;  // Up
            if (gravity.includes('l')) invertX = true;  // Left
            
            // Reset stats
            stats = { startTime: Date.now(), endTime: 0, totalFrames: 0, totalRenderTime: 0 };

            // 1. Prepare Weights
            statusText.textContent = "CALCULATING WEIGHTS...";
            await new Promise(r => setTimeout(r, 10)); 
            weightData = calculateWeights(pixelData, width, height);

            // 2. Setup Recording
            if (isRecordingMode) {
                statusText.textContent = "RECORDING BUFFER...";
                stream = canvas.captureStream(60); 
                
                const mimeTypes = [
                    'video/webm; codecs=vp9', 
                    'video/webm; codecs=vp8', 
                    'video/webm',             
                    'video/mp4'
                ];
                let options = { videoBitsPerSecond: 80000000 };
                let supportedType = null;
                for (const type of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        supportedType = type;
                        break;
                    }
                }
                if (supportedType) options.mimeType = supportedType;
                
                try {
                    mediaRecorder = new MediaRecorder(stream, options);
                } catch (err) {
                    console.error('MediaRecorder init failed:', err);
                    statusText.textContent = "RECORDER ERROR (SEE CONSOLE)";
                    isSorting = false;
                    btnReset.disabled = false;
                    return;
                }

                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                };
                mediaRecorder.start();
            }

            // 3. Animation Loop
            let frameCount = 0;
            let consecutiveIdleFrames = 0;
            const maxFrames = (width + height) * 2; 
            const bufferFrames = 60;
            let loopState = isRecordingMode ? 'intro' : 'sorting'; 

            function step() {
                if (!isSorting) return;
                
                // Track Render Time
                const t0 = performance.now();

                // --- LOGIC ---
                if (loopState === 'intro') {
                    frameCount++;
                    statusText.textContent = `RECORDING INTRO (${Math.floor((frameCount/bufferFrames)*100)}%)`;
                    if (frameCount >= bufferFrames) {
                        loopState = 'sorting';
                        frameCount = 0;
                    }
                } 
                else if (loopState === 'sorting') {
                    let changes = false;
                    
                    // Determine which pass to run based on Mode
                    let performVertical = false;
                    let performHorizontal = false;
                    
                    if (mode === 'xy') {
                        if (frameCount % 2 === 0) performVertical = true;
                        else performHorizontal = true;
                    } else if (mode === 'y') {
                        performVertical = true;
                    } else if (mode === 'x') {
                        performHorizontal = true;
                    }

                    // Physics Pass
                    if (performVertical) {
                        // Vertical Pass
                        for (let y = 0; y < height - 1; y += 2) {
                            const rowOffset = y * width;
                            const nextRowOffset = (y + 1) * width;
                            for (let x = 0; x < width; x++) {
                                const idx1 = rowOffset + x;
                                const idx2 = nextRowOffset + x;
                                let shouldSwap = invertY 
                                    ? (weightData[idx1] > weightData[idx2]) 
                                    : (weightData[idx1] < weightData[idx2]);
                                    
                                if (shouldSwap) { 
                                    swap(idx1, idx2);
                                    changes = true;
                                }
                            }
                        }
                        for (let y = 1; y < height - 1; y += 2) {
                            const rowOffset = y * width;
                            const nextRowOffset = (y + 1) * width;
                            for (let x = 0; x < width; x++) {
                                const idx1 = rowOffset + x;
                                const idx2 = nextRowOffset + x;
                                let shouldSwap = invertY 
                                    ? (weightData[idx1] > weightData[idx2]) 
                                    : (weightData[idx1] < weightData[idx2]);

                                if (shouldSwap) {
                                    swap(idx1, idx2);
                                    changes = true;
                                }
                            }
                        }
                    } 
                    
                    if (performHorizontal) {
                        // Horizontal Pass
                        for (let y = 0; y < height; y++) {
                            const rowOffset = y * width;
                            for (let x = 0; x < width - 1; x += 2) {
                                const idx1 = rowOffset + x;
                                const idx2 = rowOffset + x + 1;
                                let shouldSwap = invertX 
                                    ? (weightData[idx1] > weightData[idx2]) 
                                    : (weightData[idx1] < weightData[idx2]);

                                if (shouldSwap) {
                                    swap(idx1, idx2);
                                    changes = true;
                                }
                            }
                        }
                        for (let y = 0; y < height; y++) {
                            const rowOffset = y * width;
                            for (let x = 1; x < width - 1; x += 2) {
                                const idx1 = rowOffset + x;
                                const idx2 = rowOffset + x + 1;
                                let shouldSwap = invertX 
                                    ? (weightData[idx1] > weightData[idx2]) 
                                    : (weightData[idx1] < weightData[idx2]);

                                if (shouldSwap) {
                                    swap(idx1, idx2);
                                    changes = true;
                                }
                            }
                        }
                    }

                    // Update UI
                    const newImageData = new ImageData(pixelData, width, height);
                    ctx.putImageData(newImageData, 0, 0);

                    // Check Stability
                    if (changes) consecutiveIdleFrames = 0;
                    else consecutiveIdleFrames++;

                    if (consecutiveIdleFrames >= 4) { 
                        if (isRecordingMode) {
                            loopState = 'outro';
                            frameCount = 0;
                        } else {
                            finishSortingOnly();
                            return; 
                        }
                    } else {
                        frameCount++;
                        stats.totalFrames++;
                        // For single axis modes, progress bar might be inaccurate since maxFrames estimates XY travel
                        // But it's just an estimate, so it's fine.
                        const pct = Math.min(100, (frameCount / maxFrames) * 100);
                        progressBar.style.width = `${pct}%`;
                        statusText.textContent = `SORTING... FRAME ${frameCount}`;
                    }
                } 
                else if (loopState === 'outro') {
                    frameCount++;
                    statusText.textContent = `RECORDING OUTRO (${Math.floor((frameCount/bufferFrames)*100)}%)`;
                    if (frameCount >= bufferFrames) {
                        finishRecording();
                        return; // Stop Loop
                    }
                }
                
                // End Stats Tracking
                const t1 = performance.now();
                if (loopState === 'sorting') {
                    stats.totalRenderTime += (t1 - t0);
                }
                updateStatsUI();

                // Request next frame
                animationId = requestAnimationFrame(step);
            }

            step();
        }

        function updateStatsUI() {
            const elapsed = Date.now() - stats.startTime;
            statTime.textContent = (elapsed / 1000).toFixed(1) + "s";
            statFrames.textContent = stats.totalFrames;
            
            if (stats.totalFrames > 0) {
                const avgMs = stats.totalRenderTime / stats.totalFrames;
                statRender.textContent = avgMs.toFixed(2) + "ms";
                // Estimate max possible FPS based on render time
                const estFps = 1000 / avgMs;
                statFps.textContent = estFps > 60 ? "60+" : estFps.toFixed(0);
            }
        }

        function finishSortingOnly() {
            isSorting = false;
            statusText.textContent = "SORTING COMPLETE";
            progressBar.style.width = '100%';
            btnReset.disabled = false;
        }

        function finishRecording() {
            isSorting = false;
            statusText.textContent = "FINALIZING VIDEO...";
            mediaRecorder.stop();
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                videoURL = URL.createObjectURL(blob);
                statusText.textContent = "COMPLETE. DOWNLOAD READY.";
                btnReset.disabled = false;
                btnDownload.disabled = false;
                progressBar.style.width = '100%';
                progressBar.classList.add('bg-green-500');
            };
        }

        function downloadVideo() {
            if (!videoURL) return;
            const a = document.createElement('a');
            a.href = videoURL;
            a.download = 'pixel_sort_result.webm';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                canvasWrapper.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }
    </script>
</body>
</html>
