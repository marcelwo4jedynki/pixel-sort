<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Time Pixel Sorter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom scrollbar for minimalist look */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #fff; }
        ::-webkit-scrollbar-thumb { background: #000; border: 2px solid #fff; }
        
        /* Hide cursor in fullscreen if needed */
        .fullscreen-canvas { cursor: none; }

        /* Panning Cursors */
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-crosshair { cursor: crosshair; }
        
        /* Canvas Transitions for smooth zoom toggle */
        #canvas, #mask-canvas {
            transition: transform 0.1s linear; /* Fast interaction */
        }
        
        /* Fit Mode */
        .canvas-fit {
            max-width: 100%;
            max-height: 100%;
            /* Removed object-fit: contain to fix coordinate mapping bugs.
               Flexbox in the parent will handle centering and aspect ratio
               by shrinking the element itself. */
        }

        /* FIX: Center the mask canvas when in fit mode. 
           The main canvas is centered by the parent's flexbox.
           Since the mask is absolute, we must manually center it to match.
        */
        #mask-canvas.canvas-fit {
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* 1:1 Mode */
        .canvas-1to1 {
            max-width: none;
            max-height: none;
            position: absolute; /* Allows translation relative to wrapper */
            top: 0;
            left: 0;
            /* Transform is handled via JS inline styles */
        }

        /* Help Popover Animations */
        .help-popover {
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s;
            opacity: 0;
            visibility: hidden; /* Use visibility to fully hide interaction when transparent */
            transform: translateY(10px);
            /* Delay hiding to create "semi-solid" lingering feel */
            transition-delay: 0.1s; 
        }
        .help-popover.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            transition-delay: 0s; /* Instant appearance */
        }
    </style>
</head>
<body class="bg-white text-black font-mono antialiased flex flex-col h-screen overflow-hidden selection:bg-black selection:text-white">

    <!-- Header & Stats Dashboard -->
    <header class="border-b-2 border-black z-30 bg-white flex flex-col shrink-0">
        <!-- Main Title Row -->
        <div class="flex justify-between items-center px-4 sm:px-6 py-3 sm:py-4">
            <h1 class="text-lg sm:text-xl font-bold tracking-tighter uppercase truncate">Real Time Pixel Sorter <span class="hidden sm:inline text-xs font-normal opacity-50 ml-2">v3.7 Artist Mode</span></h1>
            <div class="text-xs font-bold bg-black text-white px-2 py-1 uppercase tracking-wider transition-colors shrink-0" id="status-text">WAITING</div>
        </div>
        
        <!-- Stats Bar (Always Visible) -->
        <div class="flex flex-wrap border-t border-gray-200 bg-gray-50 px-4 sm:px-6 py-2 gap-x-6 gap-y-1 text-xs font-mono uppercase tracking-tight overflow-x-auto whitespace-nowrap">
             <div class="flex gap-2 items-center">
                <i data-lucide="timer" class="w-3 h-3 text-gray-400"></i>
                <span class="text-gray-400">Time:</span>
                <span id="stat-time" class="font-bold">--</span>
             </div>
             <div class="flex gap-2 items-center">
                <i data-lucide="layers" class="w-3 h-3 text-gray-400"></i>
                <span class="text-gray-400">Frames:</span>
                <span id="stat-frames" class="font-bold">--</span>
             </div>
             <div class="flex gap-2 items-center">
                <i data-lucide="cpu" class="w-3 h-3 text-gray-400"></i>
                <span class="text-gray-400">Render:</span>
                <span id="stat-render" class="font-bold">--</span>
             </div>
             <div class="flex gap-2 items-center">
                <i data-lucide="activity" class="w-3 h-3 text-gray-400"></i>
                <span class="text-gray-400">FPS:</span>
                <span id="stat-fps" class="font-bold">--</span>
             </div>
        </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 relative flex items-center justify-center bg-gray-50 overflow-hidden p-4" id="main-container">
        
        <!-- Empty State / Drop Zone -->
        <div id="drop-zone" class="absolute inset-4 border-2 border-dashed border-gray-300 flex flex-col items-center justify-center text-gray-400 hover:border-black hover:text-black transition-colors cursor-pointer z-10">
            <i data-lucide="upload" class="w-12 h-12 mb-4"></i>
            <p class="uppercase text-sm tracking-widest text-center px-4">Drop Image or Tap to Upload</p>
            <input type="file" id="file-input" class="hidden" accept="image/*">
        </div>

        <!-- Resize Dialog (Hidden by default) -->
        <div id="resize-dialog" class="absolute inset-0 bg-white/90 z-20 hidden flex flex-col items-center justify-center p-8 text-center backdrop-blur-sm transition-opacity">
            <div class="max-w-lg w-full border-2 border-black bg-white p-6 sm:p-8 shadow-2xl">
                <h2 class="text-xl sm:text-2xl font-bold mb-4 uppercase tracking-tighter">Large Image Detected</h2>
                <div class="grid grid-cols-2 gap-4 text-sm mb-6 border-y border-gray-200 py-4">
                    <div class="text-right pr-4 border-r border-gray-200">
                        <div class="text-gray-400 text-xs uppercase">Original</div>
                        <div id="dialog-img-dims" class="font-bold text-lg"></div>
                    </div>
                    <div class="text-left pl-4">
                        <div class="text-gray-400 text-xs uppercase">Your Screen</div>
                        <div id="dialog-screen-dims" class="font-bold text-lg"></div>
                    </div>
                </div>
                <p class="mb-8 text-gray-600 text-sm">
                    This image is larger than your workspace. Scaling it down will significantly improve sorting speed.
                </p>
                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="btn-resize-fit" class="px-6 py-3 bg-black text-white font-bold uppercase hover:bg-gray-800 transition-colors flex-1">
                        Scale to Screen
                    </button>
                    <button id="btn-keep-orig" class="px-6 py-3 border-2 border-black font-bold uppercase hover:bg-gray-100 transition-colors flex-1">
                        Keep Original
                    </button>
                </div>
            </div>
        </div>

        <!-- Reset Confirmation Dialog -->
        <div id="confirm-reset-dialog" class="absolute inset-0 bg-white/90 z-30 hidden flex flex-col items-center justify-center p-8 text-center backdrop-blur-sm">
            <div class="max-w-md w-full border-2 border-black bg-white p-8 shadow-2xl">
                <div class="flex justify-center mb-4 text-red-600">
                    <i data-lucide="alert-triangle" class="w-12 h-12"></i>
                </div>
                <h2 class="text-xl font-bold mb-2 uppercase tracking-tighter">Interrupt Recording?</h2>
                <p class="mb-8 text-gray-600 text-sm">
                    A recording is currently in progress. Resetting now will discard the video file.
                </p>
                <div class="flex gap-4 justify-center">
                    <button id="btn-confirm-reset" class="px-6 py-2 bg-red-600 text-white font-bold uppercase hover:bg-red-700 transition-colors flex-1">
                        Yes, Reset
                    </button>
                    <button id="btn-cancel-reset" class="px-6 py-2 border-2 border-black font-bold uppercase hover:bg-gray-100 transition-colors flex-1">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Render Complete / Download Dialog -->
        <div id="download-dialog" class="absolute inset-0 bg-white/95 z-40 hidden flex flex-col items-center justify-center p-8 text-center backdrop-blur-md animate-in fade-in zoom-in-95 duration-200">
            <div class="max-w-lg w-full border-4 border-black bg-white p-8 shadow-2xl relative">
                <button id="btn-close-dl" class="absolute top-4 right-4 text-gray-400 hover:text-black transition-colors">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
                
                <div class="flex justify-center mb-6 text-green-600">
                    <i data-lucide="check-circle-2" class="w-16 h-16"></i>
                </div>
                
                <h2 class="text-3xl font-black mb-2 uppercase tracking-tighter">Render Complete</h2>
                <p class="mb-8 text-gray-600">Your pixel sort recording is ready.</p>
                
                <div class="flex flex-col gap-4">
                    <button id="btn-dl-video-main" class="w-full py-4 bg-black text-white text-lg font-bold uppercase hover:bg-gray-800 transition-colors flex items-center justify-center gap-3">
                        <i data-lucide="film" class="w-5 h-5"></i> Download Video
                    </button>
                    
                    <button id="btn-dl-image-main" class="w-full py-3 border-2 border-black text-black font-bold uppercase hover:bg-gray-100 transition-colors flex items-center justify-center gap-2">
                        <i data-lucide="image" class="w-8 h-8"></i> Download Current Frame
                    </button>
                </div>
                
                <div class="mt-6 pt-6 border-t border-gray-100">
                     <button id="btn-restart-dl" class="text-xs uppercase font-bold text-gray-400 hover:text-black tracking-widest">
                        Close & Continue Editing
                     </button>
                </div>
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="relative shadow-2xl border-4 border-black hidden flex flex-col justify-center items-center overflow-hidden bg-gray-100 cursor-grab" 
             style="width: 100%; height: 100%;" 
             id="canvas-wrapper">
            
            <canvas id="canvas" class="canvas-fit z-0" title="Click to load a new image (or Drag to Pan in 1:1)"></canvas>
            <canvas id="mask-canvas" class="canvas-fit absolute top-0 left-0 z-10 pointer-events-none opacity-60 mix-blend-multiply hidden"></canvas>
            
            <div id="progress-bar-container" class="absolute bottom-0 left-0 h-1 bg-black w-0 transition-all duration-300 z-10"></div>
        </div>

    </main>

    <!-- Controls Footer -->
    <footer class="border-t-2 border-black bg-white p-4 z-30 shrink-0 relative">
        <div class="flex flex-col gap-4 max-w-7xl mx-auto">
            
            <!-- Top Row: Config -->
            <div class="flex flex-wrap gap-4 items-center justify-center text-sm text-gray-500 pb-2 border-b border-gray-100 relative">
                
                <span id="resolution-display" class="font-mono text-xs hidden sm:inline">0 x 0</span>
                <div class="h-4 w-px bg-gray-300 hidden sm:block"></div>
                
                <button id="btn-zoom-toggle" class="flex items-center gap-2 hover:text-black transition-colors" title="Toggle 1:1 View">
                    <i data-lucide="zoom-in" class="w-4 h-4"></i>
                    <span id="zoom-label" class="text-xs uppercase font-bold">Fit</span>
                </button>
                
                <div class="h-4 w-px bg-gray-300 hidden sm:block"></div>
                
                <!-- Artist Mode Toggle -->
                <label class="flex items-center gap-2 cursor-pointer hover:text-black select-none group">
                    <div class="relative">
                        <input type="checkbox" id="artist-mode-toggle" class="peer sr-only">
                        <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-black rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-black"></div>
                    </div>
                    <span class="text-xs uppercase font-bold group-hover:text-black">Artist Mode</span>
                </label>

                <div class="h-4 w-px bg-gray-300 hidden sm:block"></div>

                <!-- Controls Group with Titles & Help -->
                <div class="flex flex-wrap gap-4 justify-center items-end">
                    
                    <!-- Color Space Select -->
                    <div class="flex flex-col gap-1 relative group">
                        <div class="flex items-center gap-1 text-[10px] font-bold text-gray-400 uppercase cursor-help select-none help-trigger" data-target="help-colorspace">
                            Color Space <i data-lucide="help-circle" class="w-3 h-3"></i>
                        </div>
                        <select id="color-mode" class="bg-gray-50 border border-gray-200 rounded px-1 py-1 font-bold uppercase text-xs cursor-pointer outline-none hover:border-black transition-colors min-w-[100px]">
                            <option value="cielab" selected>CIELAB (L*)</option>
                            <option value="smart">Smart (HSV+)</option>
                            <option value="luma">Luma (709)</option>
                            <option value="classic">Classic (8b)</option>
                            <option value="sat">Saturation</option>
                            <option value="red">Red Ch.</option>
                            <option value="green">Green Ch.</option>
                            <option value="blue">Blue Ch.</option>
                        </select>
                        <!-- Popover -->
                <div id="help-colorspace" class="help-popover absolute bottom-full left-0 mb-2 w-80 bg-white border-2 border-black shadow-xl p-4 z-50 text-xs text-left max-h-[80vh] overflow-y-auto">
                            <h4 class="font-bold uppercase border-b border-gray-200 pb-1 mb-2">About Color Spaces</h4>
                            <p class="text-gray-600 mb-3 leading-relaxed">
                                A color space determines how pixels are weighted. We calculate a numerical value for every color and then sort them. The previews below show 4,096 uniformly distributed colors sorted by each algorithm, revealing the gradient curve created by that math.
                            </p>
                            
                            <div class="space-y-4">
                                <!-- CIELAB -->
                                <div class="flex gap-3 items-start">
                                    <canvas data-mode="cielab" class="preview-canvas w-16 h-16 border border-gray-300 bg-gray-100 shrink-0 image-render-pixel"></canvas>
                                    <div>
                                        <strong class="block uppercase text-[10px] tracking-wide mb-1">CIELAB (L*)</strong>
                                        <span class="text-gray-500 leading-tight block">Perceptually accurate lightness (how the human eye sees brightness). Very smooth.</span>
                                    </div>
                                </div>
                                <!-- Smart -->
                                <div class="flex gap-3 items-start">
                                    <canvas data-mode="smart" class="preview-canvas w-16 h-16 border border-gray-300 bg-gray-100 shrink-0 image-render-pixel"></canvas>
                                    <div>
                                        <strong class="block uppercase text-[10px] tracking-wide mb-1">Smart (HSV+)</strong>
                                        <span class="text-gray-500 leading-tight block">Sorts by Brightness, but uses Hue to break ties. Creates complex, glitchy gradients.</span>
                                    </div>
                                </div>
                                <!-- Luma -->
                                <div class="flex gap-3 items-start">
                                    <canvas data-mode="luma" class="preview-canvas w-16 h-16 border border-gray-300 bg-gray-100 shrink-0 image-render-pixel"></canvas>
                                    <div>
                                        <strong class="block uppercase text-[10px] tracking-wide mb-1">Luma (Rec. 709)</strong>
                                        <span class="text-gray-500 leading-tight block">Standard video grayscale brightness. Accurate but technical.</span>
                                    </div>
                                </div>
                                <!-- Classic -->
                                <div class="flex gap-3 items-start">
                                    <canvas data-mode="classic" class="preview-canvas w-16 h-16 border border-gray-300 bg-gray-100 shrink-0 image-render-pixel"></canvas>
                                    <div>
                                        <strong class="block uppercase text-[10px] tracking-wide mb-1">Classic (8-bit)</strong>
                                        <span class="text-gray-500 leading-tight block">Rounds values to step intervals. Creates sediment-like layers and banding.</span>
                                    </div>
                                </div>
                                <!-- Saturation -->
                                <div class="flex gap-3 items-start">
                                    <canvas data-mode="sat" class="preview-canvas w-16 h-16 border border-gray-300 bg-gray-100 shrink-0 image-render-pixel"></canvas>
                                    <div>
                                        <strong class="block uppercase text-[10px] tracking-wide mb-1">Saturation</strong>
                                        <span class="text-gray-500 leading-tight block">Sorts from grayscale (low) to vivid neon colors (high).</span>
                                    </div>
                                </div>
                                <!-- Red -->
                                <div class="flex gap-3 items-start">
                                    <canvas data-mode="red" class="preview-canvas w-16 h-16 border border-gray-300 bg-gray-100 shrink-0 image-render-pixel"></canvas>
                                    <div>
                                        <strong class="block uppercase text-[10px] tracking-wide mb-1">Red Channel</strong>
                                        <span class="text-gray-500 leading-tight block">Sorts based purely on how much Red is in the pixel.</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Axis Select -->
                    <div class="flex flex-col gap-1 relative group">
                        <div class="flex items-center gap-1 text-[10px] font-bold text-gray-400 uppercase cursor-help select-none help-trigger" data-target="help-axis">
                            Axis <i data-lucide="help-circle" class="w-3 h-3"></i>
                        </div>
                        <select id="sort-mode" class="bg-gray-50 border border-gray-200 rounded px-1 py-1 font-bold uppercase text-xs cursor-pointer outline-none hover:border-black transition-colors min-w-[80px]">
                            <option value="xy">XY Mix</option>
                            <option value="y">Y Only</option>
                            <option value="x">X Only</option>
                        </select>
                        <div id="help-axis" class="help-popover absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-48 bg-white border-2 border-black shadow-xl p-3 z-50 text-xs text-left hidden">
                            <h4 class="font-bold uppercase border-b border-gray-200 pb-1 mb-2">Sorting Axis</h4>
                            <ul class="space-y-1 text-gray-600 list-disc pl-4">
                                <li><strong>XY Mix:</strong> Fluid 2D movement.</li>
                                <li><strong>Y Only:</strong> Sorts columns (Up/Down).</li>
                                <li><strong>X Only:</strong> Sorts rows (Left/Right).</li>
                            </ul>
                        </div>
                    </div>
                    
                    <!-- Gravity Select -->
                    <div class="flex flex-col gap-1 relative group">
                        <div class="flex items-center gap-1 text-[10px] font-bold text-gray-400 uppercase cursor-help select-none help-trigger" data-target="help-gravity">
                            Gravity <i data-lucide="help-circle" class="w-3 h-3"></i>
                        </div>
                        <select id="gravity-direction" class="bg-gray-50 border border-gray-200 rounded px-1 py-1 font-bold uppercase text-xs cursor-pointer outline-none hover:border-black transition-colors min-w-[80px]">
                            <!-- Populated via JS -->
                        </select>
                        <div id="help-gravity" class="help-popover absolute bottom-full right-0 mb-2 w-48 bg-white border-2 border-black shadow-xl p-3 z-50 text-xs text-left hidden">
                            <h4 class="font-bold uppercase border-b border-gray-200 pb-1 mb-2">Gravity Direction</h4>
                            <p class="text-gray-600">Determines where bright pixels fall.</p>
                        </div>
                    </div>

                    <!-- DEFAULTS Button -->
                     <button id="btn-defaults" class="ml-2 px-2 py-1 bg-gray-100 border border-gray-300 text-[10px] uppercase font-bold text-gray-400 hover:text-black hover:border-black transition-colors" title="Reset Settings & Disable Artist Mode">
                        Default
                     </button>
                </div>
            </div>

            <!-- Artist Mode Toolbar (Hidden by default) -->
            <div id="artist-toolbar" class="hidden flex-wrap gap-4 items-center justify-center bg-gray-50 p-2 border border-gray-200 rounded-lg animate-in fade-in slide-in-from-top-2 duration-200">
                <div class="flex items-center gap-2 border-r border-gray-300 pr-4 mr-2">
                    <span class="text-[10px] font-bold uppercase text-gray-400">Tools</span>
                    <!-- Tool: Brush -->
                    <button class="tool-btn p-2 border border-transparent rounded hover:bg-white hover:border-gray-300 active:bg-gray-200 transition-all active-tool" data-tool="brush" title="Circle Brush">
                        <i data-lucide="brush" class="w-4 h-4"></i>
                    </button>
                    <!-- Tool: Box -->
                    <button class="tool-btn p-2 border border-transparent rounded hover:bg-white hover:border-gray-300 active:bg-gray-200 transition-all" data-tool="rect" title="Box Selection">
                        <i data-lucide="box-select" class="w-4 h-4"></i>
                    </button>
                    <!-- Tool: Col -->
                    <button class="tool-btn p-2 border border-transparent rounded hover:bg-white hover:border-gray-300 active:bg-gray-200 transition-all" data-tool="col" title="Column Section">
                        <i data-lucide="columns" class="w-4 h-4"></i>
                    </button>
                    <!-- Tool: Row -->
                    <button class="tool-btn p-2 border border-transparent rounded hover:bg-white hover:border-gray-300 active:bg-gray-200 transition-all" data-tool="row" title="Row Section">
                        <i data-lucide="rows" class="w-4 h-4"></i>
                    </button>
                </div>

                <!-- Brush Settings -->
                <div class="flex items-center gap-3 border-r border-gray-300 pr-4 mr-2" id="brush-settings">
                    <span class="text-[10px] font-bold uppercase text-gray-400">Size</span>
                    <input type="range" id="brush-size" min="5" max="200" value="50" class="w-24 h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Mode Settings -->
                <div class="flex items-center gap-2">
                     <span class="text-[10px] font-bold uppercase text-gray-400">Action</span>
                     <div class="flex bg-white border border-gray-200 rounded overflow-hidden">
                        <button class="draw-mode-btn px-3 py-1 text-xs font-bold uppercase hover:bg-gray-50 active-mode bg-black text-white" data-mode="draw">Draw</button>
                        <button class="draw-mode-btn px-3 py-1 text-xs font-bold uppercase hover:bg-gray-50" data-mode="erase">Erase</button>
                     </div>
                </div>
                 
                 <!-- Mask Actions -->
                 <div class="flex items-center ml-2 gap-2 border-l border-gray-300 pl-4">
                     <!-- Undo -->
                     <button id="btn-undo-mask" class="p-1 hover:bg-white rounded hover:text-black text-gray-500 transition-colors" title="Undo Mask Change">
                        <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                     </button>
                     <!-- Invert -->
                     <button id="btn-invert-mask" class="text-[10px] font-bold uppercase text-black hover:text-gray-600 hover:underline">Invert</button>
                     <!-- Clear -->
                     <button id="btn-clear-mask" class="text-[10px] font-bold uppercase text-red-500 hover:text-red-700 hover:underline">Clear</button>
                 </div>
            </div>

            <!-- Bottom Row: Buttons -->
            <div class="flex flex-wrap gap-3 justify-center items-center">
                <button id="btn-reset" class="px-4 py-2 border-2 border-black uppercase text-xs font-bold hover:bg-black hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled>
                    Reset
                </button>
                <button id="btn-use-input" class="px-4 py-2 border-2 border-black uppercase text-xs font-bold hover:bg-gray-100 transition-colors disabled:opacity-30 disabled:cursor-not-allowed" title="Use result as input" disabled>
                    Use as Input
                </button>
                
                <div class="w-px bg-gray-300 mx-1 h-6 hidden sm:block"></div>
                
                <button id="btn-sort" class="flex-1 sm:flex-none px-6 py-2 border-2 border-black uppercase text-xs font-bold hover:bg-black hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled>
                    Start
                </button>
                <button id="btn-record" class="flex-1 sm:flex-none px-6 py-2 border-2 border-black bg-black text-white uppercase text-xs font-bold hover:bg-white hover:text-black transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled>
                    Record
                </button>

                <div class="w-px bg-gray-300 mx-1 h-6 hidden sm:block"></div>

                <div class="flex gap-2">
                    <button id="btn-fullscreen" class="p-2 border-2 border-black hover:bg-black hover:text-white transition-colors" title="Maximize">
                        <i data-lucide="maximize" class="w-4 h-4"></i>
                    </button>
                    <button id="btn-download" class="p-2 border-2 border-black hover:bg-black hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed" disabled title="Download Image (PNG)">
                        <i data-lucide="image-down" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    </footer>

    <script>
        // --- Icons ---
        lucide.createIcons();

        // --- Core Elements ---
        const mainContainer = document.getElementById('main-container');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        
        // Canvas Layers
        const canvas = document.getElementById('canvas');
        const maskCanvas = document.getElementById('mask-canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const maskCtx = maskCanvas.getContext('2d');
        
        // Dialog Elements
        const resizeDialog = document.getElementById('resize-dialog');
        const dialogImgDims = document.getElementById('dialog-img-dims');
        const dialogScreenDims = document.getElementById('dialog-screen-dims');
        const btnResizeFit = document.getElementById('btn-resize-fit');
        const btnKeepOrig = document.getElementById('btn-keep-orig');

        // Reset Confirmation Elements
        const confirmResetDialog = document.getElementById('confirm-reset-dialog');
        const btnConfirmReset = document.getElementById('btn-confirm-reset');
        const btnCancelReset = document.getElementById('btn-cancel-reset');

        // Download Dialog Elements
        const downloadDialog = document.getElementById('download-dialog');
        const btnDlVideoMain = document.getElementById('btn-dl-video-main');
        const btnDlImageMain = document.getElementById('btn-dl-image-main');
        const btnCloseDl = document.getElementById('btn-close-dl');
        const btnRestartDl = document.getElementById('btn-restart-dl');

        // Buttons & Stats
        const btnSort = document.getElementById('btn-sort');
        const btnRecord = document.getElementById('btn-record');
        const btnReset = document.getElementById('btn-reset');
        const btnUseInput = document.getElementById('btn-use-input');
        const btnDownload = document.getElementById('btn-download');
        const btnFullscreen = document.getElementById('btn-fullscreen');
        const btnZoomToggle = document.getElementById('btn-zoom-toggle');
        const zoomLabel = document.getElementById('zoom-label');
        const sortModeInput = document.getElementById('sort-mode');
        const gravityInput = document.getElementById('gravity-direction');
        const colorModeInput = document.getElementById('color-mode');
        const btnDefaults = document.getElementById('btn-defaults');
        
        // Artist Mode Elements
        const artistToggle = document.getElementById('artist-mode-toggle');
        const artistToolbar = document.getElementById('artist-toolbar');
        const toolBtns = document.querySelectorAll('.tool-btn');
        const brushSizeInput = document.getElementById('brush-size');
        const drawModeBtns = document.querySelectorAll('.draw-mode-btn');
        const btnClearMask = document.getElementById('btn-clear-mask');
        const btnInvertMask = document.getElementById('btn-invert-mask');
        const btnUndoMask = document.getElementById('btn-undo-mask');
        
        const statusText = document.getElementById('status-text');
        const resDisplay = document.getElementById('resolution-display');
        const progressBar = document.getElementById('progress-bar-container');
        
        // Stat fields
        const statTime = document.getElementById('stat-time');
        const statFrames = document.getElementById('stat-frames');
        const statRender = document.getElementById('stat-render');
        const statFps = document.getElementById('stat-fps');

        // --- State ---
        let originalImage = null;
        let animationId = null;
        let isSorting = false;
        let currentRunIsRecording = false;
        
        // View State
        let viewMode = 'fit'; 
        let pan = { x: 0, y: 0 };
        let isPanning = false;
        let startPan = { x: 0, y: 0 };
        let wasPanning = false;

        // Artist Mode State
        let isArtistMode = false;
        let maskData = null; // Uint8Array: 0 = locked, 1 = sortable
        let maskHistory = []; // Undo stack
        let currentTool = 'brush'; // 'brush', 'rect', 'col', 'row'
        let isDrawing = false;
        let drawStartPos = { x: 0, y: 0 };
        let drawMode = 'draw'; // 'draw' or 'erase'
        let tempMaskSnapshot = null; // For shapes preview

        // Statistics State
        let stats = { startTime: 0, endTime: 0, totalFrames: 0, totalRenderTime: 0 };
        
        // Data Buffers
        let pixelData = null;
        let weightData = null;
        let width = 0;
        let height = 0;

        // Recording State
        let mediaRecorder = null;
        let recordedChunks = [];
        let videoURL = null;

        // --- ARTIST MODE SETUP ---

        artistToggle.addEventListener('change', (e) => {
            isArtistMode = e.target.checked;
            if (isArtistMode) {
                artistToolbar.classList.remove('hidden');
                artistToolbar.classList.add('flex');
                maskCanvas.classList.remove('hidden');
                canvasWrapper.classList.add('cursor-crosshair');
                canvasWrapper.classList.remove('cursor-grab');
                
                // Initialize mask if needed
                if (!maskData && width > 0 && height > 0) {
                    initMaskData();
                    renderMaskOverlay();
                }
            } else {
                artistToolbar.classList.add('hidden');
                artistToolbar.classList.remove('flex');
                maskCanvas.classList.add('hidden');
                canvasWrapper.classList.remove('cursor-crosshair');
                canvasWrapper.classList.add('cursor-grab');
            }
        });

        // Tool Selection
        toolBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                toolBtns.forEach(b => {
                    b.classList.remove('bg-black', 'text-white', 'active-tool');
                    b.classList.add('hover:bg-white');
                });
                btn.classList.add('bg-black', 'text-white', 'active-tool');
                btn.classList.remove('hover:bg-white');
                currentTool = btn.dataset.tool;
            });
        });

        // Draw/Erase Toggle
        drawModeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                drawModeBtns.forEach(b => {
                    b.classList.remove('bg-black', 'text-white');
                    b.classList.add('hover:bg-gray-50');
                });
                btn.classList.add('bg-black', 'text-white');
                btn.classList.remove('hover:bg-gray-50');
                drawMode = btn.dataset.mode;
            });
        });

        function saveMaskHistory() {
             if (!maskData) return;
             if (maskHistory.length > 20) maskHistory.shift(); // Limit stack
             maskHistory.push(new Uint8Array(maskData));
        }

        btnUndoMask.addEventListener('click', () => {
             if (maskHistory.length === 0 || !maskData) return;
             const prev = maskHistory.pop();
             maskData.set(prev);
             renderMaskOverlay();
        });

        btnClearMask.addEventListener('click', () => {
            if (!maskData) return;
            saveMaskHistory();
            maskData.fill(0);
            renderMaskOverlay();
        });

        btnInvertMask.addEventListener('click', () => {
            if (!maskData) return;
            saveMaskHistory();
            for (let i = 0; i < maskData.length; i++) {
                maskData[i] = maskData[i] === 1 ? 0 : 1;
            }
            renderMaskOverlay();
        });

        function initMaskData() {
            maskData = new Uint8Array(width * height);
            maskData.fill(0); // Start empty
            maskHistory = []; // Reset history on new image
        }

        function renderMaskOverlay() {
            if (!maskData || width === 0 || height === 0) return;
            
            // We draw the selection as Green.
            // Clear
            maskCtx.clearRect(0, 0, width, height);
            
            const imgData = maskCtx.createImageData(width, height);
            const data = imgData.data;
            
            for (let i = 0; i < width * height; i++) {
                if (maskData[i] === 1) {
                    const idx = i * 4;
                    data[idx] = 0;     // R
                    data[idx+1] = 255; // G (Green selection)
                    data[idx+2] = 0;   // B
                    data[idx+3] = 100; // Alpha
                }
            }
            maskCtx.putImageData(imgData, 0, 0);
        }

        // --- MOUSE INTERACTIONS (DRAWING VS PANNING) ---

        // Helper to get coordinates relative to canvas
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            // Calculate scale in case of fit mode
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            return {
                x: Math.floor((e.clientX - rect.left) * scaleX),
                y: Math.floor((e.clientY - rect.top) * scaleY)
            };
        }

        canvasWrapper.addEventListener('mousedown', (e) => {
            if (isArtistMode && width > 0) {
                isDrawing = true;
                saveMaskHistory(); // Save before stroke
                const coords = getCanvasCoords(e);
                drawStartPos = coords;
                
                if (currentTool !== 'brush') {
                    // Save snapshot for shape preview
                    tempMaskSnapshot = new Uint8Array(maskData);
                } else {
                    applyBrush(coords.x, coords.y);
                }
            } else if (viewMode === '1to1') {
                // Normal Panning Logic
                isPanning = true;
                wasPanning = false;
                startPan.x = e.clientX - pan.x;
                startPan.y = e.clientY - pan.y;
                canvasWrapper.classList.add('cursor-grabbing');
                canvasWrapper.classList.remove('cursor-grab');
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isArtistMode && isDrawing && width > 0) {
                const coords = getCanvasCoords(e);
                
                if (currentTool === 'brush') {
                    applyBrush(coords.x, coords.y);
                } else {
                    // Shape Preview
                    previewShape(coords.x, coords.y);
                }
            } else if (isPanning && viewMode === '1to1') {
                wasPanning = true;
                pan.x = e.clientX - startPan.x;
                pan.y = e.clientY - startPan.y;
                updateCanvasTransform();
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (isArtistMode && isDrawing) {
                isDrawing = false;
                const coords = getCanvasCoords(e);
                if (currentTool !== 'brush') {
                    applyShape(coords.x, coords.y);
                }
                tempMaskSnapshot = null;
            }
            if (isPanning) {
                isPanning = false;
                canvasWrapper.classList.remove('cursor-grabbing');
                if (viewMode === '1to1') canvasWrapper.classList.add('cursor-grab');
            }
        });

        // --- DRAWING LOGIC ---

        function applyBrush(cx, cy) {
            const size = parseInt(brushSizeInput.value);
            const r = size / 2;
            const rSq = r * r;
            const val = drawMode === 'draw' ? 1 : 0;
            
            // Bounding box to optimize loop
            const minX = Math.max(0, Math.floor(cx - r));
            const maxX = Math.min(width, Math.ceil(cx + r));
            const minY = Math.max(0, Math.floor(cy - r));
            const maxY = Math.min(height, Math.ceil(cy + r));
            
            let changed = false;
            for (let y = minY; y < maxY; y++) {
                for (let x = minX; x < maxX; x++) {
                    const dx = x - cx;
                    const dy = y - cy;
                    if (dx*dx + dy*dy <= rSq) {
                        const idx = y * width + x;
                        if (maskData[idx] !== val) {
                            maskData[idx] = val;
                            changed = true;
                        }
                    }
                }
            }
            if (changed) renderMaskOverlay();
        }

        function previewShape(cx, cy) {
            // Restore snapshot first
            maskData.set(tempMaskSnapshot);
            
            const sx = drawStartPos.x;
            const sy = drawStartPos.y;
            const val = drawMode === 'draw' ? 1 : 0;
            
            fillShape(sx, sy, cx, cy, val);
            renderMaskOverlay();
        }

        function applyShape(cx, cy) {
            // Finalize shape
            renderMaskOverlay();
        }

        function fillShape(x1, y1, x2, y2, val) {
            let minX, maxX, minY, maxY;
            
            if (currentTool === 'rect') {
                minX = Math.min(x1, x2);
                maxX = Math.max(x1, x2);
                minY = Math.min(y1, y2);
                maxY = Math.max(y1, y2);
            } else if (currentTool === 'col') {
                // Vertical Strip: Width is defined by drag, Height is FULL
                minX = Math.min(x1, x2);
                maxX = Math.max(x1, x2);
                minY = 0;
                maxY = height;
            } else if (currentTool === 'row') {
                // Horizontal Strip: Height is defined by drag, Width is FULL
                minX = 0;
                maxX = width;
                minY = Math.min(y1, y2);
                maxY = Math.max(y1, y2);
            }

            // Clamp
            minX = Math.max(0, minX);
            maxX = Math.min(width, maxX);
            minY = Math.max(0, minY);
            maxY = Math.min(height, maxY);

            for (let y = minY; y < maxY; y++) {
                const rowOffset = y * width;
                for (let x = minX; x < maxX; x++) {
                    maskData[rowOffset + x] = val;
                }
            }
        }


        // --- HELP SYSTEM (EXISTING) ---
        const helpTriggers = document.querySelectorAll('.help-trigger');
        let activePopover = null;

        helpTriggers.forEach(trigger => {
            trigger.addEventListener('mouseenter', (e) => { if (window.matchMedia("(hover: hover)").matches) showPopover(trigger.dataset.target); });
            trigger.addEventListener('mouseleave', (e) => { if (window.matchMedia("(hover: hover)").matches) hidePopover(trigger.dataset.target); });
            trigger.addEventListener('click', (e) => {
                e.stopPropagation();
                const targetId = trigger.dataset.target;
                const popover = document.getElementById(targetId);
                if (activePopover && activePopover !== popover) {
                    activePopover.classList.remove('active');
                    setTimeout(() => activePopover?.classList.add('hidden'), 300);
                }
                if (popover.classList.contains('active')) { hidePopover(targetId); activePopover = null; } 
                else { showPopover(targetId); activePopover = popover; }
            });
        });

        document.addEventListener('click', (e) => {
            if (activePopover && !activePopover.contains(e.target)) { hidePopover(activePopover.id); activePopover = null; }
        });

        function showPopover(id) {
            const popover = document.getElementById(id);
            popover.classList.remove('hidden');
            requestAnimationFrame(() => popover.classList.add('active'));
        }

        function hidePopover(id) {
            const popover = document.getElementById(id);
            popover.classList.remove('active');
            setTimeout(() => { if (!popover.classList.contains('active')) popover.classList.add('hidden'); }, 300);
        }

        // --- PREVIEW GENERATION ---
        window.addEventListener('load', generatePreviews);
        function generatePreviews() {
            const previews = document.querySelectorAll('.preview-canvas');
            const pW = 64, pH = 64, totalPixels = pW * pH;
            const uniformData = new Uint8ClampedArray(totalPixels * 4);
            let idx = 0;
            for(let r=0; r<16; r++) for(let g=0; g<16; g++) for(let b=0; b<16; b++) {
                uniformData[idx*4] = r * 17; uniformData[idx*4+1] = g * 17; uniformData[idx*4+2] = b * 17; uniformData[idx*4+3] = 255; idx++;
            }
            previews.forEach(pCanvas => {
                pCanvas.width = pW; pCanvas.height = pH;
                const pCtx = pCanvas.getContext('2d');
                const localPixelData = new Uint8ClampedArray(uniformData);
                const weights = calculateWeights(localPixelData, pW, pH, pCanvas.dataset.mode);
                const indices = new Uint32Array(totalPixels);
                for(let i=0; i<totalPixels; i++) indices[i] = i;
                indices.sort((a, b) => weights[a] - weights[b]);
                const sortedPixelData = new Uint8ClampedArray(totalPixels * 4);
                for(let i=0; i<totalPixels; i++) {
                    const originalIdx = indices[i];
                    sortedPixelData[i*4] = localPixelData[originalIdx*4];
                    sortedPixelData[i*4+1] = localPixelData[originalIdx*4+1];
                    sortedPixelData[i*4+2] = localPixelData[originalIdx*4+2];
                    sortedPixelData[i*4+3] = 255;
                }
                pCtx.putImageData(new ImageData(sortedPixelData, pW, pH), 0, 0);
            });
        }

        // --- CORE UI LOGIC ---
        function updateGravityOptions() {
            const mode = sortModeInput.value;
            gravityInput.innerHTML = '';
            let options = [];
            if (mode === 'xy') options = [{ val: 'dr', text: '↘ Dn-Rt' }, { val: 'dl', text: '↙ Dn-Lt' }, { val: 'ur', text: '↗ Up-Rt' }, { val: 'ul', text: '↖ Up-Lt' }];
            else if (mode === 'y') options = [{ val: 'd', text: '↓ Down' }, { val: 'u', text: '↑ Up' }];
            else if (mode === 'x') options = [{ val: 'r', text: '→ Right' }, { val: 'l', text: '← Left' }];
            options.forEach(opt => { const el = document.createElement('option'); el.value = opt.val; el.textContent = opt.text; gravityInput.appendChild(el); });
        }
        updateGravityOptions();
        
        // Settings Change Listeners
        sortModeInput.addEventListener('change', () => { updateGravityOptions(); handleSettingChange(); });
        gravityInput.addEventListener('change', handleSettingChange);
        colorModeInput.addEventListener('change', handleSettingChange);

        function handleSettingChange() {
             // Only auto-update if we have an image and aren't currently sorting
             if (width > 0 && !isSorting) {
                 setAsInput(true); // silent true
             }
        }
        
        // Defaults Button
        btnDefaults.addEventListener('click', () => {
             artistToggle.checked = false;
             artistToggle.dispatchEvent(new Event('change'));
             colorModeInput.value = 'cielab';
             sortModeInput.value = 'xy';
             updateGravityOptions();
             handleSettingChange();
        });

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('bg-gray-100'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('bg-gray-100'));
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
        
        btnZoomToggle.addEventListener('click', toggleZoomMode);
        canvasWrapper.addEventListener('click', (e) => {
            if (viewMode === '1to1' && wasPanning) { wasPanning = false; return; }
            if (isSorting || isArtistMode) return; // Disable upload click in artist mode
            fileInput.click();
        });

        btnSort.addEventListener('click', () => startSortingProcess(false));
        btnRecord.addEventListener('click', () => startSortingProcess(true));
        btnReset.addEventListener('click', () => { if (isSorting && currentRunIsRecording) confirmResetDialog.classList.remove('hidden'); else resetCanvasState(); });
        btnUseInput.addEventListener('click', () => setAsInput(false));
        btnConfirmReset.addEventListener('click', () => { confirmResetDialog.classList.add('hidden'); resetCanvasState(); });
        btnCancelReset.addEventListener('click', () => confirmResetDialog.classList.add('hidden'));
        
        // Updated Download Logic
        btnDownload.addEventListener('click', downloadImage);
        btnDlVideoMain.addEventListener('click', downloadVideo);
        btnDlImageMain.addEventListener('click', downloadImage);
        btnCloseDl.addEventListener('click', () => downloadDialog.classList.add('hidden'));
        btnRestartDl.addEventListener('click', () => downloadDialog.classList.add('hidden'));

        btnFullscreen.addEventListener('click', toggleFullscreen);
        btnResizeFit.addEventListener('click', () => { resizeDialog.classList.add('hidden'); initCanvas(originalImage, true); });
        btnKeepOrig.addEventListener('click', () => { resizeDialog.classList.add('hidden'); initCanvas(originalImage, false); });

        // --- FILE HANDLING ---
        function handleDrop(e) {
            e.preventDefault(); dropZone.classList.remove('bg-gray-100');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        }
        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => { originalImage = img; checkDimensionsAndInit(img); };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        function checkDimensionsAndInit(img) {
            const pad = 40, availW = mainContainer.clientWidth - pad, availH = mainContainer.clientHeight - pad;
            if (img.width > availW * 1.2 || img.height > availH * 1.2) {
                dialogImgDims.textContent = `${img.width} x ${img.height}`; dialogScreenDims.textContent = `${availW} x ${availH}`;
                resizeDialog.classList.remove('hidden'); dropZone.classList.add('hidden');
            } else { dropZone.classList.add('hidden'); initCanvas(img, false); }
        }

        // --- CANVAS OPS ---
        function setAsInput(silent = false) {
            if (!width || !height) return;
            const dataURL = canvas.toDataURL();
            if (isSorting) {
                isSorting = false; cancelAnimationFrame(animationId);
                if (mediaRecorder && mediaRecorder.state !== 'inactive') { mediaRecorder.onstop = null; mediaRecorder.stop(); }
                btnSort.disabled = false; btnRecord.disabled = false;
            }
            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                resetCanvasState();
                if (!silent) {
                    statusText.textContent = "IMAGE UPDATED"; statusText.classList.add('bg-blue-600', 'text-white');
                    setTimeout(() => { if (!isSorting) { statusText.textContent = "READY"; statusText.classList.remove('bg-blue-600'); } }, 1500);
                }
            };
            newImg.src = dataURL;
        }

        function toggleZoomMode() {
            if (!width || !height) return;
            if (viewMode === 'fit') {
                viewMode = '1to1'; zoomLabel.textContent = "1:1 View";
                canvas.classList.remove('canvas-fit'); canvas.classList.add('canvas-1to1');
                maskCanvas.classList.remove('canvas-fit'); maskCanvas.classList.add('canvas-1to1');
                if(!isArtistMode) {
                    canvasWrapper.classList.add('cursor-grab');
                    canvasWrapper.classList.remove('justify-center', 'items-center');
                }
                const wrapperW = canvasWrapper.clientWidth, wrapperH = canvasWrapper.clientHeight;
                pan.x = (wrapperW - width) / 2; pan.y = (wrapperH - height) / 2; updateCanvasTransform();
            } else {
                viewMode = 'fit'; zoomLabel.textContent = "Fit";
                canvas.classList.add('canvas-fit'); canvas.classList.remove('canvas-1to1');
                maskCanvas.classList.add('canvas-fit'); maskCanvas.classList.remove('canvas-1to1');
                canvasWrapper.classList.remove('cursor-grab', 'cursor-grabbing');
                canvasWrapper.classList.add('justify-center', 'items-center');
                canvas.style.transform = ''; maskCanvas.style.transform = '';
            }
        }
        function updateCanvasTransform() {
            if (viewMode === '1to1') {
                canvas.style.transform = `translate(${pan.x}px, ${pan.y}px)`;
                maskCanvas.style.transform = `translate(${pan.x}px, ${pan.y}px)`;
            }
        }

        function resetCanvasState() {
            if (animationId) cancelAnimationFrame(animationId);
            if (mediaRecorder && mediaRecorder.state !== 'inactive') { mediaRecorder.onstop = null; mediaRecorder.stop(); }
            isSorting = false; currentRunIsRecording = false;
            if (videoURL) URL.revokeObjectURL(videoURL);
            downloadDialog.classList.add('hidden');
            // Download button now stays enabled if image exists
            btnSort.disabled = false; btnRecord.disabled = false; btnUseInput.disabled = false;
            progressBar.style.width = '0%'; progressBar.classList.remove('bg-green-500'); statusText.textContent = "READY";
            statTime.textContent = "--"; statFrames.textContent = "--"; statRender.textContent = "--"; statFps.textContent = "--";
            
            if (width && height && originalImage) {
                ctx.drawImage(originalImage, 0, 0, width, height);
                pixelData = ctx.getImageData(0, 0, width, height).data;
            }
            if (viewMode === '1to1') toggleZoomMode();
        }

        function initCanvas(img, resizeToFit) {
            resetCanvasState();
            let w = img.width, h = img.height; const maxDim = 3840;
            if (resizeToFit) {
                const pad = 40, availW = mainContainer.clientWidth - pad, availH = mainContainer.clientHeight - pad;
                const ratio = Math.min(availW / w, availH / h); w = Math.round(w * ratio); h = Math.round(h * ratio);
            } else {
                if (w > maxDim || h > maxDim) { const ratio = Math.min(maxDim / w, maxDim / h); w = Math.round(w * ratio); h = Math.round(h * ratio); }
            }
            canvas.width = w; canvas.height = h;
            maskCanvas.width = w; maskCanvas.height = h;
            width = w; height = h;
            
            ctx.drawImage(img, 0, 0, w, h);
            pixelData = ctx.getImageData(0, 0, w, h).data;
            initMaskData();
            renderMaskOverlay(); // Clear any existing

            canvasWrapper.classList.remove('hidden');
            resDisplay.textContent = `${w} x ${h}`; statusText.textContent = "READY";
            btnSort.disabled = false; btnRecord.disabled = false; btnReset.disabled = false; 
            btnDownload.disabled = false; // Enable image download immediately
            btnUseInput.disabled = false;
            
            viewMode = 'fit'; zoomLabel.textContent = "Fit";
            canvas.classList.add('canvas-fit'); canvas.classList.remove('canvas-1to1');
            maskCanvas.classList.add('canvas-fit'); maskCanvas.classList.remove('canvas-1to1');
            canvasWrapper.classList.add('justify-center', 'items-center'); canvasWrapper.classList.remove('cursor-grab');
            canvas.style.transform = ''; maskCanvas.style.transform = '';
        }

        // --- SORTING LOGIC ---
        function calculateWeights(data, w, h, modeOverride = null) {
            const weights = new Float32Array(w * h);
            const mode = modeOverride || colorModeInput.value;
            for (let i = 0; i < w * h; i++) {
                const idx = i * 4;
                const r = data[idx], g = data[idx+1], b = data[idx+2];
                const rn = r/255, gn = g/255, bn = b/255;
                let weight = 0;
                if (mode === 'smart') {
                    const max = Math.max(rn, gn, bn), min = Math.min(rn, gn, bn), d = max - min;
                    let hue = 0;
                    if (max !== min) {
                        if (max === rn) hue = (gn - bn) / d + (gn < bn ? 6 : 0);
                        else if (max === gn) hue = (bn - rn) / d + 2;
                        else if (max === bn) hue = (rn - gn) / d + 4;
                        hue /= 6;
                    }
                    weight = max + (hue * 0.005);
                } 
                else if (mode === 'classic') { weight = Math.floor((0.299*r + 0.587*g + 0.114*b)/24)*24; }
                else if (mode === 'cielab') {
                    const lin = (c) => (c <= 0.04045) ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                    const Y = 0.2126 * lin(rn) + 0.7152 * lin(gn) + 0.0722 * lin(bn);
                    const f = (t) => (t > 0.008856) ? Math.pow(t, 1/3) : (7.787 * t) + (16 / 116);
                    weight = (116 * f(Y)) - 16;
                }
                else if (mode === 'luma') { weight = 0.2126 * rn + 0.7152 * gn + 0.0722 * bn; }
                else if (mode === 'sat') { const max = Math.max(rn, gn, bn), min = Math.min(rn, gn, bn); weight = (max === 0) ? 0 : (max - min) / max; }
                else if (mode === 'red') weight = rn + gn*0.001 + bn*0.001;
                else if (mode === 'green') weight = gn + rn*0.001 + bn*0.001;
                else if (mode === 'blue') weight = bn + rn*0.001 + gn*0.001;
                weights[i] = weight;
            }
            return weights;
        }

        function swap(i1, i2) {
            const tempW = weightData[i1]; weightData[i1] = weightData[i2]; weightData[i2] = tempW;
            const p1 = i1 * 4, p2 = i2 * 4;
            const r = pixelData[p1], g = pixelData[p1+1], b = pixelData[p1+2], a = pixelData[p1+3];
            pixelData[p1] = pixelData[p2]; pixelData[p1+1] = pixelData[p2+1]; pixelData[p1+2] = pixelData[p2+2]; pixelData[p1+3] = pixelData[p2+3];
            pixelData[p2] = r; pixelData[p2+1] = g; pixelData[p2+2] = b; pixelData[p2+3] = a;
        }

        async function startSortingProcess(isRecordingMode) {
            if (isSorting) return;
            isSorting = true;
            currentRunIsRecording = isRecordingMode;
            btnSort.disabled = true; btnRecord.disabled = true; btnReset.disabled = false; btnUseInput.disabled = false; 
            // btnDownload remains active to grab snapshots if needed, but video dl happens at end
            
            const mode = sortModeInput.value;
            const gravity = gravityInput.value;
            let invertX = gravity.includes('l'), invertY = gravity.includes('u');
            
            // Check if we have an active mask
            let hasActiveMask = false;
            if (isArtistMode && maskData) {
                // Quick check if mask is empty
                for(let i=0; i<maskData.length; i++) {
                    if (maskData[i] === 1) { hasActiveMask = true; break; }
                }
            }

            stats = { startTime: Date.now(), endTime: 0, totalFrames: 0, totalRenderTime: 0 };
            statusText.textContent = "CALCULATING WEIGHTS...";
            await new Promise(r => setTimeout(r, 10)); 
            weightData = calculateWeights(pixelData, width, height);

            if (isRecordingMode) {
                statusText.textContent = "RECORDING BUFFER...";
                stream = canvas.captureStream(60); 
                try {
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: 80000000 });
                } catch (e) { mediaRecorder = new MediaRecorder(stream); }
                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.start();
            }

            let frameCount = 0, consecutiveIdleFrames = 0;
            const maxFrames = (width + height) * 2; 
            let loopState = isRecordingMode ? 'intro' : 'sorting'; 

            function step() {
                if (!isSorting) return;
                const t0 = performance.now();

                if (loopState === 'intro') {
                    frameCount++; statusText.textContent = `RECORDING INTRO (${Math.floor((frameCount/60)*100)}%)`;
                    if (frameCount >= 60) { loopState = 'sorting'; frameCount = 0; }
                } 
                else if (loopState === 'sorting') {
                    let changes = false;
                    let performVertical = (mode === 'xy' && frameCount % 2 === 0) || mode === 'y';
                    let performHorizontal = (mode === 'xy' && frameCount % 2 !== 0) || mode === 'x';

                    if (performVertical) {
                        for (let y = 0; y < height - 1; y += 2) processRowPair(y, y+1);
                        for (let y = 1; y < height - 1; y += 2) processRowPair(y, y+1);
                    } 
                    if (performHorizontal) {
                        for (let y = 0; y < height; y++) {
                            const rowOffset = y * width;
                            for (let x = 0; x < width - 1; x += 2) processSwap(rowOffset+x, rowOffset+x+1, invertX);
                            for (let x = 1; x < width - 1; x += 2) processSwap(rowOffset+x, rowOffset+x+1, invertX);
                        }
                    }

                    function processRowPair(y1, y2) {
                        const r1 = y1 * width, r2 = y2 * width;
                        for (let x = 0; x < width; x++) processSwap(r1+x, r2+x, invertY);
                    }

                    function processSwap(idx1, idx2, invert) {
                        // MASK CHECK: If masking is active, only swap if BOTH pixels are selected (1)
                        if (hasActiveMask) {
                            if (maskData[idx1] === 0 || maskData[idx2] === 0) return;
                        }

                        let shouldSwap = invert ? (weightData[idx1] > weightData[idx2]) : (weightData[idx1] < weightData[idx2]);
                        if (shouldSwap) { swap(idx1, idx2); changes = true; }
                    }

                    ctx.putImageData(new ImageData(pixelData, width, height), 0, 0);

                    if (changes) consecutiveIdleFrames = 0; else consecutiveIdleFrames++;
                    if (consecutiveIdleFrames >= 4) { 
                        if (isRecordingMode) { loopState = 'outro'; frameCount = 0; } else { finishSortingOnly(); return; }
                    } else {
                        frameCount++; stats.totalFrames++;
                        progressBar.style.width = `${Math.min(100, (frameCount / maxFrames) * 100)}%`;
                        statusText.textContent = `SORTING... FRAME ${frameCount}`;
                    }
                } 
                else if (loopState === 'outro') {
                    frameCount++; statusText.textContent = `RECORDING OUTRO (${Math.floor((frameCount/60)*100)}%)`;
                    if (frameCount >= 60) { finishRecording(); return; }
                }
                
                stats.totalRenderTime += (performance.now() - t0);
                updateStatsUI();
                animationId = requestAnimationFrame(step);
            }
            step();
        }

        function updateStatsUI() {
            statTime.textContent = ((Date.now() - stats.startTime) / 1000).toFixed(1) + "s";
            statFrames.textContent = stats.totalFrames;
            if (stats.totalFrames > 0) {
                const avgMs = stats.totalRenderTime / stats.totalFrames;
                statRender.textContent = avgMs.toFixed(2) + "ms";
                statFps.textContent = (1000 / avgMs).toFixed(0);
            }
        }
        function finishSortingOnly() { 
            isSorting = false; 
            statusText.textContent = "SORTING COMPLETE"; 
            progressBar.style.width = '100%'; 
            btnReset.disabled = false;
        }
        function finishRecording() {
            isSorting = false; statusText.textContent = "FINALIZING VIDEO..."; mediaRecorder.stop();
            mediaRecorder.onstop = () => {
                videoURL = URL.createObjectURL(new Blob(recordedChunks, { type: 'video/webm' }));
                statusText.textContent = "COMPLETE";
                btnReset.disabled = false; 
                progressBar.style.width = '100%'; 
                progressBar.classList.add('bg-green-500');
                
                // Show "In Your Face" Download Dialog
                downloadDialog.classList.remove('hidden');
            };
        }
        function downloadVideo() { if (videoURL) { const a = document.createElement('a'); a.href = videoURL; a.download = 'pixel_sort_result.webm'; document.body.appendChild(a); a.click(); document.body.removeChild(a); } }
        
        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'pixel_sort_frame.png';
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function toggleFullscreen() { if (!document.fullscreenElement) canvasWrapper.requestFullscreen(); else document.exitFullscreen(); }
    </script>
</body>
</html>
